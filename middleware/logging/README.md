# Go: RequestBodyLogMiddleware の解説

2025/08/23 結局難しくてよくわからんかった。。。

## 趣旨
- HTTPリクエストのボディを読み取り、ログに残すためのミドルウェア  
- 読み取った後にボディを再セットして、元のハンドラでも通常通り使用可能にする  
- 主な用途は API デバッグやリクエストトレーシング

---

## 処理の流れ

1. **リクエストボディの読み取り**  
   - `r.Body` は `io.ReadCloser` 型で、ネットワーク接続やバッファに紐づくリソースを持つ  
   - `io.ReadAll(r.Body)` でボディをすべて読み込む  
   - 読み込み後は r.Body が EOF になるため、次のハンドラで直接は使えない  

2. **エラーハンドリング**  
   - ボディ読み込みに失敗した場合はログに出力し、HTTP 400 を返す  

3. **r.Body の再代入（再セット）**  
   - 読み込んだ内容を `bytes.NewBuffer(body)` に入れて Reader を作成  
   - `io.NopCloser` で空の Close() を付与して `io.ReadCloser` に変換  
   - これを r.Body に再代入することで、次のハンドラでも安全にボディを読み込める  
   - 理由: ReadAll で消費した Body は EOF になっており、そのままでは次のハンドラで読めないため

4. **defer r.Body.Close()**  
   - ミドルウェア内で使い終わった Body を確実に閉じる  
   - リソースリーク防止

5. **次のハンドラへ渡す**  
   - `next.ServeHTTP(w, r)` で元のハンドラにリクエストを渡す  
   - これによりミドルウェアチェーンが構築できる  

---

## Close() のTips
- リクエストボディやファイルなど、リソースを持つものは必ず Close() する  
- defer で閉じるのが安全で一般的  
- io.NopCloser を使うと再セット後でも defer が安全に呼べる  
- Close() を忘れるとメモリリークや接続不足の原因になる

---

> まとめ: このミドルウェアは **リクエストボディを安全にログしつつ、次のハンドラでも利用可能にする安全装置** である
