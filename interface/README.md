# なぜ最小のインターフェースがいいのか

## 柔軟性が高い

- 小さいインターフェースは、より多くの型に適合しやすい。
- たとえば Recv() だけ求める Receiverインターフェースに対し、Modem でも Phone でも FaxMachine でも適合させられる。
- 逆に、「Dial / Hangup / Recv / Send 全部必要」なインターフェースだと、すべて実装してないと使えない＝使える型が限定されてしまう。

## テストのモックをつくるのが楽

- 大きなインターフェース（メソッドが多い）だと、全部モックする必要があって面倒。一個だと簡単。

```go
type DummyReceiver struct{}

func (DummyReceiver) Recv() {
    fmt.Println("Dummy receiving...")
}
```

## 疎結合になる

- 関数やモジュールが本当に必要なメソッドにだけ依存するので、責務が明確。

- 「受信だけ必要な処理」に Dial() や Hangup() まで含んだ Modem を渡すのは設計として過剰。

## 変更に強くなる

- インターフェースが小さいと、既存コードへの影響が少ない。

- たとえば Modem に Restart() を追加しても、Receiver インターフェースには関係ないので receiveData() は一切変わらない。
  - 他の言語だとインターフェースも改修になってる（とくにPHP！）

----

# おまけ

インテーフェースは慣例として命名時にはサフィックスに`er`(XXXをする者)をつけるといい。
